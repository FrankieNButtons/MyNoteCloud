# <center>操作系统课堂笔记</center>
## Chap1：操作系统概论
### 操作系统的各种定义
 - `资源分配者`：管理和分配各种资源。
 - `控制程序`：控制`用户程序`的运行与`I/O设备`的操作
 - `内核`：在`全时`运行的一个程序，其他被称为`应用`
### 计算机的启动
 - 引导程序（Bootstrap Program）
    1. 存储在**固件**中（ROM或EPROM）
### 操作系统的功能
 - 对计算机的`软件和硬件`资源进行管理
 - 是计算机软硬件进行交互的`接口`，是硬件之上的`第一层软件`

### 操作系统的目标
 - `执行`用户程序使用户的问题`更容易解决`
 - 使计算机系统`更易于使用`
 - 使硬件的使用`更有效率`
 - 

### 操作系统的发展体现（核心是`需求推动发展`）
 - **资源利用角度**：提高资源利用率与系统性能：
    1. 从单道到多道；
    2. 从集中到分布；
    3. 从专用到泛在；
 - **人机交互角度**：优化人机交互、方便用户使用（`分时系统`的出现）
 - **技术发展角度**：硬件的发展迭代（新功能特性的涌现）、规模的不断扩展
### 操作系统的发展历史（共5代）
 - **第一代（1946~1955）**：ENIAC（十进制，纸带存储，无操作系统，真空管计算机）
 - **第二代（1955~1965）**：晶体管时代（主要是批处理系统）
 - **第三代（1965~1980）**：集成电路（`多道程序`批处理系统，仍为批处理系统，但已有分时系统设计的思想）
 - **第四代（1980~至今）**：大规模与超大规模集成电路（分时系统，向巨型、微型、并行、分布式、网络化、智能化等方向发展）
### 操作系统的分类和发展历程
 - 无操作系统：人工操作，`用户独占全机`，使用`机器语言`编程，使用`纸带或卡片`I/O，始终是`CPU等待用户`，使用效率低
 - 简单批处理系统：使用`脱机I/O`的方式，将一批任务通过磁带或磁鼓预载到主机前或主机后再进行处理或输出，每批作业由`专门监督程序`自动依次处理
    1. `顺序性`：各道作业是**顺序执行**的
    2. `单道性`：内存中只能有**一个任务**同时执行
    3. `自动性`
    -  **存在的问题**：CPU与I/O不能同时使用，`忙闲不均`
 - 多道程序批处理系统：内存中有多个作业，CPU在不同任务中切换，只要系统中存在可执行的任务，CPU就不会空闲
    1. **多道性**：内存中同时`驻留多道程序并发执行`，有效提高资源利用率与系统吞吐量。
    2. **无序性**：作业的完成顺序与他进入内存的顺序之间无`严格的对应关系`。
    3. **调度性**：有`作业调度`和`进程调度`的流程。
    - **存在的问题**：无`交互能力`，用户响应时间长，作业`平均周转时间`长。
 - 分时系统：可进行`多任务处理`且`可交互`的系统
    1. **多任务处理**：分为`多用户分时`（多个程序存在内存中分别服务于不同用户，有用户输入时由CPU执行处理完后暂停，等待下一次输入）和`前后台分时`（后台程序，不占用终端I/O，不与用户交互），实现方式通常是`按时间片分配`，多个程序在CPU上执行`相同轮换时间`
    2. **提出的要求**：主机，具备`及时接收`、`及时处理`的能力（分别通过`作业直接进入内存`和`每个作业只运行很短的时间`实现）
    3. **主要特点**
       - **多路性**：众多联机用户可以同时使用一个主机
       - **独占性**：各终端用户`感觉`自己独占一台主机
       - **交互性**：用户和计算机间可以进行`会话`
       - **及时性**：用户的请求能在很短时间内获得响应
 - 实时系统：往往是`专用系统`，能够`实时控制`，具有`高可靠性`和`事件驱动`的特点
    1. **实时时钟管理**
    2. **高度可靠安全**
    3. **能够过载保护**
 - 分布式系统：是若干独立计算机的集合，但对用户来说就是单个相关系统
    - **硬件角度**：各个计算机都是`自治`的，通过`网络`互联
    - **软件角度**：用户看到的是`一台逻辑计算机`
 - 交互式系统
 - 嵌入式系统
 - 并行系统
### 多道程序批处理系统引出的概念
 - **通道**：负责`外部设备和内存`进行数据传输的专用部件
 - **中断**：当CPU`收到某一外界指令`后，中断当前工作转而执行新插入的工作（往往是`I/O操作`），并在执行完该工作后从原中断电继续执行原工作，多个不同任务的I/O与计算可`并行执行`
   ![interuption](images/image-12.png)

## Chap2：操作系统的体系结构
### OS的定义
 - 操作系统是一个**软件**
 - 操作系统是一个**资源分配器** 
    *主要功能：*
    1. 管理所有计算机资源
    2. 处理冲突请求，公平地为用户和程序分配资源
 - 操作系统是一个**控制程序**
    1. 控制程序执行防止出错
    2. 控制各种I/O防止资源不当使用（如可以实现**外设并行**）
 - 操作系统是**一直处在运行状态的程序**，其中一直在内存中运行的部分叫**内核**，其余称**系统程序**，非操作系统的程序则为**应用程序**。
 - 不同操作系统的内核**基本功能模块设计**有所不同。
 > **备注**：一些嵌入式操作系统或基于解释型语言构建的操作系统是**没有内核态**，不在本课程讨论之列。

### 计算机系统的组成
 - `CPU`：核心组件，计算的主要执行者
 - `控制器`**（非常重要）**：对`每一类具体硬件`都有自己的控制器（如内存控制器、磁盘控制器、打印机控制器等），控制器可以使I/O设备与CPU`并行执行`，且拥有一定的`局部缓存`
    1. 通过`引起中断`来向CPU报告操作的完成
    2. 局部缓存的功能：CPU与主存交换数据的媒介、I/O发生在`I/O设备与局部缓存`间
 - `系统总线`：用于连接CPU和各种设备的控制器

### 具体介绍一下**中断**的概念
 - 现代操作系统都是`中断驱动`的
 - 中断将控制权移交给`中断服务程序`
   ![Interuption](images/image-14.png)
 - **中断向量**：中断向量是特定类型的中断处理程序在CPU中存储的`地址`，CPU根据中断向量找到中断处理程序，执行中断处理程序，一下是一些常见的中断向量
   ![interuptionVector](images/image-15.png)
#### 中断（外中断，也称`硬件中断`）机制
 - 原因：由外部设备完成某些操作后发送给CPU的指令，需要硬件支持引起，是异步执行的结果。
 - 触发：当某硬件完成了I/O操作后会发出一个中断信号（Interupt），硬件出现错误发出中断信号等
 - 
#### 陷阱（内中断，也称`软件中断`）机制
 - 原因：通常由于CPU执行程序时出现内部错误而引起
 - 触发：当CPU执行程序时，发生异常（Exception）后引起（即由`系统调用`引起的强制中断）

### 系统调用
 - 分类
    1. 进程控制
    2. 文件管理
    3. 设备管理
    4. 信息维护
    5. （设备间）通讯
### I/O结构
#### 主要设备
 1. I/O设备与其控制器相连
 2. 一组`本地缓冲器`和一组`寄存器`
 3. 有相应的`设备驱动程序`
#### 同步I/O vs. 异步I/O
 - 同步I/O：指两个事件发生时，只有在I/O事件的执行完成后才会让CPU继续执行任务，两个事件是**串行**的
 - 异步I/O：指两个事件发生时，I/O事件发生时CPU继续执行任务，直到收到I/O事件的中断指令前二者都处于异步I/O两个事件是**并行**的

### 硬件保护

- 计算机系统可能会出现诸如`使用非法指令`，`访问了不属于自己的内存地址`
- 操作系统有义务为保护硬件`进行错误修复`或`终止该进程`
- 要确保一个程序的执行`不会引起其他程序的错误`

- 将系统分为`用户态`和`特权态`（也叫`管态`或`内核态`）
- 因此，用一个`状态位`来区分系统所处的不同状态

#### “状态位”机制（寄存器内）

 - 用于确定调用资源的权限
 - 仅一位，用于区分**用户模式**和**内核模式**

#### “特权”机制用来区分安全与不安全

 - 将指令分为**特权指令**和**非特权指令**
 - 其中`特权指令`不能在用户态调用，如果应用需要主动调用只能通过`软中断`将控制权转交给操作系统（`陷入操作系统`）来实现

#### I/O保护
 - 所有I/O指令都是`特权指令`，用于确保用户不能通过`管态`来控制计算机及其硬件
 - 因此也必须要`保护中断向量`和`保护中断程序`，所以也需要进行`内存保护`

#### 内存保护
 - **避免访问错误的内存地址**：使用`基址寄存器`和`界限寄存器`（分别用于存储内存空间的`起始地址`和`空间长度`）
 - 因此，`用户态`下生成的每一个地址都需要经过以下规则检查：$$mealloc >= base register $$ $$ mealloc < base + limit$$
 - 操作系统可以在中断时提供的：
    - 更换两种寄存器位置
    - 将用户的程序段映射到内存中
    - 将出错的程序段从内存中移除
    - 访问和修改系统调用的参数

#### CPU保护
- 在用户程序出现`死循环`等长时间不执行`系统调用`或不将控制权转交给操作系统的时候，需要操作系统对CPU进行保护
- 使用`计时器`强制由操作系统中断程序
- 设置和加载计时器本身是一个`特权指令`
- 计时器在达到一定时间后会`主动触发中断`将控制权移交给操作系统

### 操作系统提供的核心服务
 - 用户角度
    - 用户界面
    - 程序执行
    - I/O管理
    - 文件系统操作
    - 通信
    - 错误检测
 - 系统角度（其他服务）
    - 资源分配
    - 资源账务
    - 访问保护
 ![SystemServiceArch](images/image-19.png)

### 操作系统的结构
#### 设计结构
 - 无结构
 - 分层结构：起源于`Dijkstra`及其学生开发的`THE`系统
 - 模块化结构：`UNIX`
 - 为内核结构
 - 可加载的内核模块：类似微内核，以`面向对象`系统服务以`本地服务器`形式向`系统客户端`提供服务，可动态加载，且互相独立，可以`互相调用`，没有`层级结构`限制。
 - 混合结构：既有`分层结构`，又有微内核（但宏观上已经是`宏内核`了），也有`内核扩展`，现代操作系统一般都属于这一类。
#### 存储结构（主要是一些基本硬件）
 - 内存：CPU唯一能直接访问的大容量存储区域
 - 告诉缓存：CPU-内存体系中的结构内辅助存储，用于匹配CPU速度和内存访问速度
 - 外部存储器：用于扩展内存存储能力，甚至具有冷存储功能的大容量存储器。
#### 内核设计理念不同
 - **微内核**：内核小、常驻内存少，系统程序易于扩展，用户软件资源利用率相对高，但可靠性低，且效率较低（以Windows为典型）；
 - **宏内核**：内核大，常驻内存多，扩展性差，用户应用软件资源利用率低，但可靠性高，且效率高（以Linux为典型）；

## Chap3：进程
### 并发 vs.并行
- 并发：在同一设备上同时运行多个程序（如**单个单核单线程**CPU），不同程序的指令有乱序执行导致一些意外错误，因此操作系统也需要将“共享变量”视为一种资源进行管理，因此操作系统往往引入**同步机制**以保证必要指令不乱序执行以避免影响共享变量出错。
- 并行：在同一设备上同时运行多个程序（如**多个单核多线程**CPU），
### 进程的一些概念与特点
 - 进程：`正在执行中`的一个程序（一个`具有独立功能`的程序在一个`数据集合`上的`动态执行`过程）
 - 程序：一段具有特定功能的代码段（与进程的概念区别在后者不包含`被执行的具体数据`和`进程控制块`）
 - 通过`多次执行`，一个程序可对应多个进程，通过`调用关系`，一个进程可包含多个程序
 - 进程是临时的，程序是永久的；进程是动态的，程序是静态的。
 - 进城的组成部分：
     1. 程序代码：`进程`的`代码`，`进程`的`代码`是`可执行文件`，`可执行文件`是`程序`的`机器码`。
     2. 数据：`进程`的`数据`，进程的数据是`该进程私有的`。
     3. 进程控制块（PCB）：`进程控制块`是`进程`的`元数据`，`进程控制块`中包含进程的`状态`、`资源`、`进程控制`等信息。
 - 进程的性质
     1. 动态性：
     2. 并发性：多个进程实体可以`同时存在于内存中`，且能在一段时间内`同时运行`。
     3. 独立性：每个进程都是一个`独立实体`，都有独立的`程序段`，`数据`和`计算机资源`分配。
     4. 异步性：ji进程会按`各自`的、`不可预知`的速度向前推进。
#### 进程的状态
 - **创建态**：`创建进程`后，进程处于`创建态`，直到`进程除CPU外的资源分配完毕`后转入`就绪态`。
 - **就绪态**：`除CPU外的资源全部就绪`的进程状态。
    - 进出条件：转入`运行态`
 - **运行态**：进程得到CPU资源并执行的状态。
    - 进入条件1：`根据操作系统调度策略分配得到CPU资源`后转为`运行态`。
    - 转出条件1：进程执行过程中遇到了`I/O事件`被中断后会进入`等待态`
    - 转出条件2：`单次运行定时器结束`、`时间片`、`进程资源被更高优先级（或其他调度原因，如参数指定或当前进程自愿）引起进程被抢占`后转`就绪态`
    > **备注**：抢占是系统调度的进程`外部`行为。
    - 转出条件3：`CPU执行完毕`转为`终止态`。
 - **等待态（阻塞态）**：进程被中断后等待`某些事件发生`时的状态。
    - 进入条件：需要`等待某事件`或`数据I/O`而转为`运行态`。
    - 转出条件：`转入条件结束后`从`等待态`转入`就绪态`。
    > **备注**：`阻塞`是进程本身的进程`内部`行为。
 - **终止态**：进程执行完毕，由`运行态`进入`终止态`。
### 进程控制块PCB
![PCBStructure](images/image.png)
![AnotherVsrsion](images/image-20.png)
### 进程调度
**按阶段分类：**
 - `长期调度程序（作业调度）`：从存储设备的缓冲池中选择进程，并将它们装入内存（新建进程）以执行。（将作业加入作业队列，几秒到几分钟，提现了`多道程序`的“道”）
 - `短期调度程序（CPU调度）`：从内存中就绪可执行的进程中选择进程，并为其中之一分配CPU。可能只需要几毫秒
 - `中期调度程序`：运行中的进程如果出现了资源不足，可能会`抽调部分运行中进程的资源`后重新分配。
**不同的进程队列：**
 - 作业队列：所有进程的集合。
 - 就绪队列：存储在主内存中的，`就绪并等待执行`的所有进程的队列
 - 设备队列：等待某一`I/O设备`的进程队列
 > **进程调度**就是进程`在不同队列间切换`的过程
**调度策略不同：**
 - `长期调度策略`：原则是`维持系统稳定`，即`合理搭配`系统中CPU为主的进程和`I/O为主`的进程。（算法也相对复杂，总体上要考虑所有系统资源）
 - `中期调度策略（图解）`：主要出现在`内存空间不足`的情况下，将部分`处于阻塞状态`（挂起）的进程换至`外存`，图解如下：
   ![中期调度图解](images/image-1.png)

### 上下文切换
 - **定义**：将CPU切换到另一个进程时需要保存原有进程的状态（PCB），同时装入新进程的保存状态。这一过程称为上下文切换。
 - **特点**：上下文切换时`系统不做其他工作`，花费的时间是系统的额外开销，时间长短与硬件支持密切相关，通常为微秒级（1us-1000$\mu$s）

### 进程操作
 - 创建：在`作业调度`和`用户登录`、`提供服务`、`应用请求`时进行
    - 新进程在`应用请求`会以`树状结构`产生`子进程`
    - 子进程可能：`与父进程共享全部资源`、`与父进程共享部分资源`、`与父进程不共享资源`
    - 进程号（PID）用于`区分不同进程`，在`类UNIX`系统中，PID是一个`正整数`，`PID>0`为父进程，`PID=0`为子进程，`PID<0`为无效进程
 - 调度：在进程就绪后由CPU调度决定何时由就绪态进入运行态
 - 撤销：运行态的进程由于某些原因被`彻底终止执行`（不再进入就绪态或等待态）
 - 阻塞：运行态的进程由于某些原因被`暂时终止执行`（进入等待态）
 - 唤醒：阻塞态的进程由于某些原因被`唤醒`（进入就绪态）
### 经典案例：有限缓存与共享内存的实现（生产者/消费者模型）
```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

#define BUFFER_SIZE 5

int buffer[BUFFER_SIZE];
int in = 0;
int out = 0;
int count = 0;

void* producer(void* arg) {
    int item = 0;
    while (1) {
        // 模拟生产一个数据
        item++;

        // 忙等：如果缓冲区满了就等待
        while (count == BUFFER_SIZE) {
            // do nothing
        }

        buffer[in] = item;
        printf("生产者生产了: %d\n", item);

        in = (in + 1) % BUFFER_SIZE;
        count++;

        usleep(100000); // 模拟耗时操作
    }
    return NULL;
}

void* consumer(void* arg) {
    int item;
    while (1) {
        // 忙等：如果缓冲区空了就等待
        while (count == 0) {
            // do nothing
        }

        item = buffer[out];
        printf("消费者消费了: %d\n", item);

        out = (out + 1) % BUFFER_SIZE;
        count--;

        usleep(150000); // 模拟耗时操作
    }
    return NULL;
}

int main() {
    pthread_t tid1, tid2;

    pthread_create(&tid1, NULL, producer, NULL);
    pthread_create(&tid2, NULL, consumer, NULL);

    pthread_join(tid1, NULL);
    pthread_join(tid2, NULL);

    return 0;
}
```
### 进程间通信（IPC）
#### 进程间消息传递的条件与过程
 - **条件**：进程间通信需要满足的条件，包括：
    - 连接的建立
       - 物理连接：`共享内存`、`硬件总线`等
       - 逻辑连接：`逻辑特性`等
    - 通过`send`/`receive`进行信息交换
 - 需要考虑的问题
    - 如何建立连接
    - 链接是否可多与两个进程共享（链接和进程的关系）
    - 1对通信进城可以有多少链接
    - 链接的容量是多大
    - 链接的容量是固定的还是可变的
    - 链接是有向的还是无向的

#### 进程间通信的不同分类方式
 - 直接通信
    - `对称通信`：进程间直接进行通信，发送者和接收者都需要知道对方的`进程号`，如`send(P, msg)`、`receive(Q, msg)`，其条件和特点如下：
        - 进程需要`显式命名`：如进程P使用send向进程Q发送信息，进程Q使用receive从进程P接收信息。
        - 此时通信连接是`自动建立`的。
        - 直接连接是`一对`进程上`唯一`的
        - 连接可以`无向`，也可以`双向`
    - `非对称通信`：发送消息依然指定接收方，但接受消息不声明发送方。
 - 间接通信：通信进程双方有一个`共享的`邮箱进程，双方都要知道其唯一`PID`，发送和接收消息都到该`共享邮箱进程`上执行。
    - 共享一个信箱进程时才能通信
    - 链接可与多个进程相关
    - 每对进程可共享多对链接
    - 连接可以`无向`，也可以`双向`
    - 进程可对邮箱进行操作：
       - 创建邮箱
       - 发送或接收消息
       - 销毁邮箱
 - 进程间通信的`阻塞性`
    - 阻塞性通信：消息发出后在`得到接收消息`前进程处于`被阻塞`状态，在接收到`接收方接受`的消息时才会`被唤醒`
    - 非阻塞性通信：消息发出后进程不需要等待接收方接受消息，进程可以继续执行其他操作
#### 进程间通信的**缓冲**问题：通过`附着于连接`的`消息队列`来实现管理（共3种类型）
 1. 0容量的`0消息`：发送者必须等待接收者
 2. n个消息长度的有界容量：链接满则发送者必须等待
 3. 无限容量：发送者从不等待

## Chap4：线程
### 从**进程**出发
#### 进程的属性
 - `资源分配`的独立单位：创建、调度、撤销时具有`较大的时空开销`（需要减小系统开销）
 - `调度执行`的基本单位：进程数目不宜过多，否则`切换频率过高`会`限制并发程度`（需要提高并发程度）
 > 这两个属性是可以`拆分`的，让`拥有资源的单位`不用频繁切换，让`切换执行和调度的单元`可以“轻装上阵”（不用`分配和释放`资源）
### 与进程的区别定义
- **线程**：进程的子集，是**进程的轻量级**，线程可以共享进程的资源，是`最小的执行单位`，也被称为`侵权的进程`。
- **进程**：**进程是**`资源分配的最小单位`，是**进程的完整状态**，切换的效率**不如线程**。

### 多线程的优点
 - `响应度高`
 - `资源共享`
 - `经济性高`
 - 充分利用`多处理器`体系结构
### 线程的分类
 - `用户线程`：同一进程的线程切换是进程内部的性能开销，不属于`操作系统的性能开销`，只有`不同进程间`的线程切换才属于，同时对操作系统而言就是进程切换调度。（也就是当进程中的`任意用户线程`发起了`系统调用`，则`整个进程`都会被阻塞）
 - `内核线程`：操作系统`以线程为单位`进行资源调度，原理同进程调度。
### 多线程模型（当用户级线程需要用到“某些系统功能”的时候）
 > **备注**：用户线程需要依赖`多线程`功能实现向`内核线程`的映射
#### 一对一模型
 - 每个用户线程都有一个内核线程与之对应内核线程可以独立调度。（实现真正并发，但切换多，性能开销大）
 - 优点：`灵活性高`，`响应度高`
 - 缺点：`开销大`，`资源浪费大`
#### 多对一模型
 - 多个用户线程对应一个内核线程，内核线程可能会被`任一`用户线程阻塞。（不能实现“完全”并发，但切换少，性能开销小）
 - 优点：`开销小`，`资源利用率高`
 - 缺点：`灵活性差`，`响应度差`
#### 多对多模型
 - 多个用户线程对应多个内核线程，内核线程可以独立调度。（实现真正并发，切换少，性能开销小）
 - 优点：`灵活性高`，`响应度高`，`开销小`，`资源利用率高`
 - 缺点：实现复杂


## Chap 5: CPU调度
### 基本概念
 - 调度对象：进程
 - **并发**：在同一时间，多个进程在CPU上并发执行，主要有两个区间：
    1. I/O区间：I/O操作，如读写文件、网络传输等。
    2. CPU区间：计算、运算等。
    3. **特点**：以I/O为主的程序以**短CPU区间**为主，
 - **分派程序**：将CPU的控制权由短期调度程序分配给进程，主要有`切换上下文`、`切换到用户模式`、`跳转到合适的位置以重新启动进程`。
 - **调度准则**：：一般是`最优化`调度准则，一般是`CPU使用率`——最大化
    - `吞吐量`——最大化
    - `平均周转时间`——最小化：一个进程`从产生到中止`的时间（包括`等待时间`）
    - `平均响应时间`——最小化：进程执行过程中处于`等待态`的时间
    - `平均等待时间`——最小化：从`键入命令`到`进程响应`的时间，主要针对`分时系统`，与`周转时间`概念基本一致。
 - 常见的调度策略
    - `先到先服务`调度策略
       ![Gantt Example](images/image-2.png)
       - 平均周转时间（$P_1$、$P_2$、$P_3$均为0时创建）：$$\frac{24+27+30}{3}=27$$
       - 平均等待时间（$P_1$、$P_2$、$P_3$均为0时创建）：$$\frac{0+24+27}{3}=17$$
    - `最短作业优先`调度策略（也叫`最短剩余时间`调度策略,分为`抢占型`和`非抢占型`两种）
       - 对于一个如下表所示的进程池：

| Process | Arrival | Burst | Waiting |
| :---: | :---: | :---: | :---: |
| $P_1$ | 0.00 | 7.00 | 0.00 |
| $P_2$ | 2.00 | 4.00 | 6.00 |
| $P_3$ | 4.00 | 1.00 | 3.00 |
| $P_4$ | 5.00 | 4.00 | 7.00 |

- **对于非抢占式策略**：  
        ![SJF(Non-Preemptive) Example](images/image-3.png)
 - **对于抢占式策略**：  
        ![SJF(Preemptive) Example](images/image-4.png)
    - `优先级调度`(根据`优先级是否可变`分为“静态策略”和“动态策略”)：进程按照优先级进行调度，优先级高优先级高，优先级低优先级低。
       - 主要问题：
          - `无穷阻塞`
          - `饥饿`
       - 解决方案：`老化`，如等待时间越长优先级升高、占用CPU时间越长优先级降低等`动态优先级`调度策略
    - `轮转`调度算法：按照一个特定的`时间片`将CPU资源以队列形式轮转给不同进程。
       - 重点：
          - 进程从`结束一个时间片`开始排队，而不仅仅是在`有CPU资源`或`新进程进入时`时排队。
    - `多级队列`调度算法：将不同进程根据不同属性排成多条队列，然后以`队列`为单位进行调度，队列内部则采用`时间片轮转`调度。
    - `多级反馈队列`调度算法：第一个队列中完不成的任务，进入下一个队列，然后进入下一个队列，直到完成所有任务。
       - 队列内部则采用`时间片轮转`调度
         - 队列按`时间片倍增`排序
         - 最后一个队列遵循`先到先服务`调度策略
         - 

 - 抢占策略：将优先级较高进程抢占CPU，优先级低进程从`运行态`释放进入`等待态`。

 - `响应比高优先`调度策略（自主探究）
    - 核心是这个公式：$$响应比 = \frac{等待时间 + CPU时间}{CPU时间}$$以他大为优先
    - 特点：可以同时满足多个调度准则：
       - `短作业优先`
       - `

## Chap6：同步工具
### 背景
![backofsync](images/image-9.png)
### 临界区
 - 概念：并发进程中可能`改变共同变量`、`更新同一个表`、写同一个文件的代码段。
 - 认为其所处位置时：进入区（上锁）、**临界区**、退出区（开锁）、剩余区
 - **具体要求**：
    - `互斥`：进程Pi在临界区内执行，其他进程不得进入临界区
    - `前进`：如果没有进程在临界区执行，那么允许不在剩余区的进程计入临界区
    - `有限等待`：从一个进程作出进入临界区的请求，直到该请求被允许为止，其他进程允许进入其临界区的次数有上限。
- - **总结**：`忙则等待`，`空则让进`，`等则有限`，`等则让权`



### 让权等待

### 信号量机制
```c
wait(s){
   while (s<=0){
      // Empty
   };
s--;
}
signal(s){
   s++;
}
```
但依然存在`忙等`问题
#### 忙等问题的解决
```c
wait(s){
   value--;
   if (s.value < 0){ 
      // add this process to waiting queue
      block(); // block current process itself
   }
}
signal(s){
   value++;
   if (s.value <= 0){
      // remove this process from waiting queue
      wakeUp(P); // wake up the head process in the waiting queue
   }
}
```
**这样就可以解决忙等问题，等待过程无需一直判断和消耗CPU资源**
### 死锁和饥饿

| P1 | P2 |
| :---: | :---: |
| wait(s) | wait(q) |
| wait(q) | wait(s) |
| Processing P1 | Processing P2 |
| signal(s) | signal(q) |
| signal(q) | signal(s) |
**如果两个进程并发，则P1阻塞在队列q，P2阻塞在队列s**
**解决方案**：s、q等队列必须有个全局的请求顺序（Chap7）

### 经典同步问题
#### 同步与互斥
 - 同步：两个进程必须要有先后执行的顺序(譬如后一个进程需要前一个进程的结果，或者二者本来就是一个大程序的前后部分)
 - 互斥：两个进程不能同时执行，只能一个一个执行，是一种`特殊的同步`。
 - 简单的同步问题案例：
    1. **前驱-后继**（此类问题信号量一般为`0初值`）
    ![qqhjfa1](images/image-6.png)
    ![qqhjfa2](images/image-5.png)
    2. 总结：
       1. 在多个并发进程中，同一信号量的wait和signal操作必须是成对出现的，`但不意味着数量一定相同`（因为分支语句）
       2. 用于表示同步关系的信号量的wait和signal操作是交叉出现在需要同步进程中的
       3. 用于表示互斥关系的信号量的wait和signal操作是出现同一进程内部

 - 简单的互斥问题案例：
    1. **售票员问题**
    ![hcwtspy](images/image-7.png)
    2. **司机与售票员问题**
    ![sjyspy](images/image-8.png)
    
#### 经典问题解析
 - “生产者-消费者”问题
    1. **有限缓冲问题**
    ![limitedCache](images/image-10.png)
    编程实现
    ![codeforthat](images/image-11.png)
 - “读者-写者”问题
    ![prequisite](images/image-16.png)
    1. 读者优先
    1. 
 - “哲学家进餐”问题
    1. 问题描述
    ![philosophorDining](images/image-17.png)
    2. 朴素实现
    ![naiveRealization](images/image-18.png)
    3. **可能出现死锁**：所有哲学家都拿起左手的筷子时
    4. **解决方案**：
       - `仅一则放`：拿不到两只筷子就不拿
       - `人数减一`：n只筷子最多只能有n-1个哲学家
       - `非对称`：奇数位先拿左手筷子，偶数位先拿右手筷子

#### 引入**管程**（被封装的“信号量”）
 - 管程：封装信号量的功能，提供`互斥`和`同步`功能
 - 组成：



## Chap7：死锁
### 死锁定义
 - 计算机系统中许多软硬件资源是独占性的，如打印机，磁带以及`文件系统内部表中的表项`，`数据库中加锁的记录`等。**（互斥，非抢占）**
 - 一组阻塞的进程中，每个进程都占有一定的资源，同时又等待其它阻塞进程释放其所占有的资源，这样，所有进程都无法获得足够的资源，这样就导致了死锁。**（占有并等待，循环等待）**

### 资源分配图（会画）
 - `圈`为进程，`方框`为资源
 - 
 - 死锁在图中的直观特点：死锁出现一定有环，无环一定不发生死锁
### 死锁的解决方法
 1. 通过`协议`避免死锁
 2. 允许系统进入死锁，`持续检测并处理`
 3. 忽略死锁，认为死锁不会发生（死锁也确实是小概率事件）
 - 绝大多数操作系统采用了`第三种`策略
### 死锁的预防
#### 死锁的特征
 - `互斥`：资源不能被多个进程共享
 - `占有并等待`：一个进程占有资源后，继续请求其他资源
 - `非抢占`：资源不能被强制剥夺
 - `循环等待`：存在一个进程的集合，使得每个进程都在等待下一个进程所占有的资源
 >**死锁的预防**：破坏死锁的四个特征中的一个或多个
#### 死锁的避免


#### 银行家算法
 - 银行家算法是`动态分配资源`的算法，主要用于`避免死锁`，其核心是`安全性`和`不安全性`。
 - 银行家算法的基本思想是：在每次分配资源前，先判断分配后是否处于安全状态，如果处于安全状态，则分配资源，否则不分配资源。
 - 银行家算法的基本步骤：
    1. 计算出当前系统的`最大需求矩阵`
    2. 计算出当前系统的`可用资源向量`
    3. 计算出当前系统的`分配矩阵`
    4. 判断当前系统是否处于安全状态
    5. 如果处于安全状态，则分配资源，否则不分配资源
 - 银行家算法的基本要素：
    1. `最大需求矩阵`：表示每个进程对每种资源的最大需求量（**必要**）
    2. `分配矩阵`：表示每个进程已经分配的资源量
    3. `可用资源向量`：表示系统中可用的资源量
    4. `需求矩阵`：表示每个进程还需要的资源量
#### 安全状态
 - 安全状态：系统处于安全状态时，表示系统可以分配资源给所有进程，并且所有进程都可以完成执行。（即`存在安全序列`的系统状态）
 - 不安全状态：系统处于不安全状态时，表示系统不能分配资源给所有进程，并且所有进程都不能完成执行。
 - 安全序列：表示系统处于安全状态时的进程执行顺序
#### 具体实施（见`code`文件夹）



## Chap8：主存（内存）管理
### 需要掌握
 - 连续内存分配、分页、分段等各种内存分配方式
 - 内存内容保护机制
 - 逻辑地址和物理地址的转换
### 地址映射
**使用两个寄存器的解决方案：**  
 - `基址寄存器`：存放物理地址的起始地址
 - `界限寄存器`：存放逻辑地址的长度
 - 逻辑地址=基址+偏移量
 - 物理地址=基址+界限+偏移量
**重定位与地址绑定：** 
 - `重定位寄存器`：与`基址寄存器`相同，存放物理地址的起始地址
 - `地址绑定`：将逻辑地址转换为物理地址的过程
 - `编译时地址绑定`：在编译时将逻辑地址转换为物理地址（往往用在**专用的**`嵌入式系统`中）
 - `静态地址绑定`：根据内存情况，将程序模块装入到内存适当的位置，之后不再改变。`静态可重定位技术`在加载时将程序中的地址全部加上重定位寄存器中的地址，装载器需要辨别程序中的地址以及操作数。
 - `动态地址绑定`：允许程序运行时在内存中移动位置，需要依赖`硬件地址变换机构`，程序在内存中`可以不连续`

 - 


### 连续内存分配
 - 内存通常分为两部分：`驻留操作系统`和`用户进程`
 - 拥有`内存保护`
#### 内存分区
 - **固定分区**：分区的`大小`是固定的。
 - **可变分区**：分区的`大小`是可变的（基于`内存分区表（链表，有基址、大小、是否空闲等字段）`实现）。
 - **孔**：内存中的`空闲分区`
#### 动态内存分配算法
**如何寻找`合适的孔`：**
 - `首次适应算法（FFT）`：从头开始`基址由小到大`搜索，找到第一个满足条件的孔分配给进程
 - `最佳适应算法（BFT）`：从头开始全局搜索，找到最小的满足条件的孔分配给进程
 - `最差适应算法（WFT）`：从头开始全局搜索，找到最大的满足条件的孔分配给进程
 - `循环首次适应算法`：从上次分配的位置开始搜索，找到第一个满足条件的孔分配给进程
 - `伙伴系统`：将内存划分为2的幂次方大小的块，分配时将相邻的块合并成一个大块，
#### 内存分页
##### 一些概念
 - **分页**：将内存划分为固定大小的`页`，每个页的大小相同，页的大小通常为2的幂次方。
 - **页表**：`为进程分配内存时`创建，用于存放每个页的`物理地址和逻辑地址`的映射关系。
 - **页表寄存器**：也分为`页表基址寄存器`和`页表长度寄存器`。
##### 基本特点
 - 只存在`内部碎片`，不存在`外部碎片`

##### 访存优化
 - **最初**：需要先访问`页表`，再根据其
 - **TLB（简称`块表`）**：
 - **层次化页表**：将`页内偏移量`的区域继续划分为`页号`和`页内偏移量`
##### 段页式内存


## Chap9: 虚拟内存
### “局部”现象
 - 在计算机执行一个程序时如果采用了“分页内存”，那么一个进程可能就只执行了一个大程序的“局部”，并认为在执行某个特定进程的时候这一部分“局部内存”会被频繁集中访问。
#### “置换”+“缺页中断”（也称`页错误处理`）
##### 页面错误引起`缺页中断`
 - 内存状态（引入`有效位`，用于引起`缺页中断`）
 - 缺页中断分为6个部分
    1. 内存加载（`检查缺页`）
    2. 发现缺页
    3. 引起`软中断`
    4. 寻找缺失页
    5. 加载缺失页
    6. 重新执行
 - “缺页中断”中的时间消耗
  - 
##### “置换”是有策略的
 - 需要考虑
    - 分配时间
    - 是否访问过（引入`访问位`）
    - 是否修改过（引入`修改位`）
 - 主要问题
    - 帧分配算法：
    > 主要分为`固定`分配和`动态`分配
    - 置换算法：
    > 主要分为`先进先出`和`最佳置换`（定义上是`最长时间不会被用到的`，而不是用到次数最少的，但程序需要用到哪些页是不确定的，所以不可能实现，所以一般用`最近最少使用`（LRU）置换，用“最近的过去”模拟“最近的未来”，因为`局部`现象的存在，所以认为有“访存聚集性”）
 - 一种**异常**
 > 诸如123412512345这种序列在4个帧分配的情况下反而比3个帧分配时缺页次数更多

|访存顺序|1|2|3|4|1|2|5|1|2|3|4|5|
|-|-|-|-|-|-|-|-|-|-|-|-|-|
|内存页1|1|1|1|4|4|4|5|-|-|5|5|-|
|内存页2|-|2|2|2|1|1|1|-|-|3|3|-|
|内存页3|-|-|3|3|3|2|2|-|-|2|4|-|
|**计数**|1|2|3|4|5|6|7|-|-|8|9|-|


|访存顺序|1|2|3|4|1|2|5|1|2|3|4|5|
|-|-|-|-|-|-|-|-|-|-|-|-|-|
|内存页1|1|1|1|1|-|-|5|5|5|5|4|4|
|内存页2|-|2|2|2|-|-|2|1|1|1|1|5|
|内存页3|-|-|3|3|-|-|3|3|2|2|2|2|
|内存页4|-|-|-|4|-|-|4|4|4|3|3|3|
|**计数**|1|2|3|4|-|-|5|6|7|8|9|10|
 - 常见的实际使用的置换算法
    - “近似LRU算法”——时钟算法（主要使用了`访问位`）：访问后置为1，在替换时先从访问位为0的开始替换，若不存在，则全部置零再替换
    - “二次机会近似LRU算法”（再引入一个`修改位`）：因为修改过的程序在被置换时涉及到`写操作`，所以置换开销大，所以优先置换未修改过的内存页，且置换优先级低于`访问位`
    - LFU、MFU等策略可以了解
 - 全局置换和局部置换
    - 全局置换：当内存页数达到上限时，从所有帧集合中挑选帧置换
    - 局部置换：当内存页数达到上限时，置换
##### 系统颠簸
###### 过程
 - 当系统内存紧张时，内存页置换的频繁`I/O`操作会导致CPU频繁等待缺失内存页再执行，导致`CPU利用率大幅下降`
 - CPU在意识到CPU利用率过低时会引入新进程来`提高多道程序设计能力`
 - 但新进程的引入会进一步加剧内存紧张


## Chap10: 存储管理

## Chap11：外部存储
### 存储方式
 - 顺序存储
 - 链接存储
 - 索引存储

## 大容量存储

## Chap13：I/O系统
### 存储管理

#### DMA机制
 - 原理：直接在内存中开辟空间，不经过CPU缓存，以减少触发CPU中断机制。
 - 条件：只有**快设备**才能进行
 - 功能：全部磁盘传输完了再进行**DMA中断**，可以大大减少中断次数（原本是1Byte一次中断）。
 - 
 


 
# 平时测试整理
## 第一次测试
### 选择题
- 无论系统是否支持线程，`进程`都是资源分配的基本单位，`线程`是系统调度的基本单位（对于不支持线程的系统，进程与线程等同）。
- 在分时系统中，一个进程的时间片耗尽时，该进程由`运行态`转入`就绪态`（注意不是`等待态`）
- 在支持多线程的系统中，进程P创建的若干个线程可以共享`进程P打开的文件`、`进程P的代码段`、`进程P打开的文件`，但不能共享`每个进程的栈指针`
- 有利于I/O为主的进程的调度策略：
    - 短作业优先（SJFS）
    - 高响应比优先（HRRF，相对）
- 有利于CPU为主的进程的调度策略：
    - 先来先服务（FCFS）
- 没有明显进程偏好的调度策略：
    - 时间片轮转（RR）
    - 优先级调度（PS，看情况）
- “当进程在建立时就为之分配所有的资源，如无法满足，则暂时不为进程分配任何资源。”的静态资源分配方法破坏了死锁的`占有并等待`条件。
- 假设系统有10个并发进程通过Wait和Signal操作共享同一临界资源，若该临界资源互斥信号量为mutex,初始值为1，则进程执行后，mutex可能的值域为`[-9, 1]`
- 时间片过大的时间片轮转算法会退化为`先来先服务`算法
- 资源的有序分配策略可以破坏死锁的`循环等待`条件
